import { format, createLogger as createLogger$1, transports } from 'winston';
import { z } from 'zod';
import { lstatSync, accessSync, constants } from 'fs';
import { table, getBorderCharacters } from 'table';
import chalk from 'chalk';
import { resolve } from 'path';
import assert from 'assert';
import prompts from 'prompts';

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/async/time.ts
var sleep = (timeout) => new Promise((resolve2) => setTimeout(resolve2, timeout));
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["error"] = "error";
  LogLevel2["warn"] = "warn";
  LogLevel2["info"] = "info";
  LogLevel2["http"] = "http";
  LogLevel2["verbose"] = "verbose";
  LogLevel2["debug"] = "debug";
  LogLevel2["silly"] = "silly";
  return LogLevel2;
})(LogLevel || {});
var LogLevelSchema = z.nativeEnum(LogLevel);
var isLogLevel = (value) => LogLevelSchema.safeParse(value).success;
var DEFAULT_LOG_LEVEL = "info" /* info */;
var setDefaultLogLevel = (level) => {
  if (!isLogLevel(level)) {
    console.warn(
      `Invalid log level specified: ${level}. Ignoring and keeping the current value of ${DEFAULT_LOG_LEVEL}`
    );
    return;
  }
  DEFAULT_LOG_LEVEL = level;
};
var createLogger = (level = DEFAULT_LOG_LEVEL, logFormat = format.cli()) => createLogger$1({
  level,
  format: logFormat,
  transports: [new transports.Console()]
});
var createModuleLogger = (module, level = DEFAULT_LOG_LEVEL) => createLogger(level, format.combine(prefix({ label: module }), format.cli()));
var createModuleInteractionLogger = (sourceModule, destinationModule, level = DEFAULT_LOG_LEVEL) => createLogger(level, format.combine(prefix({ label: `${sourceModule} \u279D ${destinationModule}` }), format.cli()));
var createWithAsyncLogger = (loggerFactory = createLogger) => (fn, { onStart, onSuccess, onError } = {}) => {
  let logger2;
  return async (...args) => {
    logger2 = logger2 != null ? logger2 : loggerFactory();
    onStart == null ? void 0 : onStart(logger2, args);
    try {
      const returnValue = await fn(...args);
      try {
        onSuccess == null ? void 0 : onSuccess(logger2, args, returnValue);
      } catch (e) {
      }
      return returnValue;
    } catch (error) {
      try {
        onError == null ? void 0 : onError(logger2, args, error);
      } catch (e) {
      }
      throw error;
    }
  };
};
var prefix = format((info, { label }) => ({
  ...info,
  message: `${label ? `[${label}] ` : ""}${info.message}`
}));
var isDirectory = (path) => {
  try {
    return lstatSync(path).isDirectory();
  } catch (e) {
    return false;
  }
};
var isFile = (path) => {
  try {
    return lstatSync(path).isFile();
  } catch (e) {
    return false;
  }
};
var isReadable = (path) => {
  try {
    return accessSync(path, constants.R_OK), true;
  } catch (e) {
    return false;
  }
};
var importDefault = async (path) => {
  const logger2 = createModuleLogger("filesystem");
  try {
    logger2.debug(`Importing default from '${path}' using dynamic import`);
    const result = await import(path);
    if (result != null && "default" in result) {
      return logger2.debug(`Found default in '${path}' using dynamic import`), result.default;
    }
    return logger2.debug(`Did not find default in '${path}' using dynamic import, returning the whole thing`), result;
  } catch (error) {
    logger2.debug(`Failed to import from '${path}' using dynamic import: ${error}`);
  }
  try {
    logger2.debug(`Importing default from '${path}' using require`);
    const result = await __require(path);
    if (result != null && result.__esModule) {
      return logger2.debug(`Found default in '${path}' using require`), result.default;
    }
    return logger2.debug(`Did not find default in '${path}' using require, returning the whole thing`), result;
  } catch (error) {
    logger2.debug(`Failed to import from '${path}' using require: ${error}`);
    throw error;
  }
};
var COLORS = {
  TRUE: chalk.rgb(0, 153, 0),
  // GREEN
  FALSE: chalk.rgb(255, 0, 0),
  // RED
  NOT_APPLICABLE: chalk.rgb(255, 128, 0),
  // ORANGE
  DEFAULT_KEY: chalk.rgb(255, 255, 255),
  // WHITE
  DEFAULT_VALUE: chalk.rgb(167, 125, 255)
  // MAGENTA
};
var printJson = (obj, pretty = true) => JSON.stringify(
  obj,
  (key, value) => typeof value === "bigint" ? value.toString(10) : value,
  pretty ? "	" : void 0
);
var printValue = (value, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  switch (true) {
    case value == null:
    case value instanceof Date:
    case typeof value !== "object":
      return valueColor(String(value));
    default:
      return printRecord(value, void 0, keyColor, valueColor);
  }
};
var printRecord = (obj, title, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  const rows = Object.entries(obj).map(([key, value]) => [
    keyColor(key),
    printValue(value, keyColor, valueColor)
  ]);
  if (title != null) {
    rows.unshift([keyColor(String(title)), ""]);
  }
  if (rows.length === 0) {
    return "";
  }
  return table(rows, {
    border: getBorderCharacters("norc"),
    spanningCells: title == null ? void 0 : [{ col: 0, row: 0, colSpan: 2 }]
  });
};
var printCrossTable = (records, headers, center, keyColor = COLORS.DEFAULT_KEY, valueColor = COLORS.DEFAULT_VALUE) => {
  var _a;
  const columns = center ? ["left", ...records.map(() => "center")].map((alignment) => ({ alignment })) : [];
  const headerRow = (_a = headers == null ? void 0 : headers.map((header) => keyColor(header))) != null ? _a : [];
  const rows = [headerRow];
  const properties = records.flatMap(Object.keys);
  const propertiesLeft = new Set(properties);
  for (const property of properties) {
    if (!propertiesLeft.has(property)) {
      continue;
    }
    propertiesLeft.delete(property);
    const values = records.map((record) => printValue(record[property], keyColor, valueColor));
    const row = [keyColor(property), ...values];
    rows.push(row);
  }
  return table(rows, { border: getBorderCharacters("norc"), columns });
};
var printBoolean = (value, nullColor = COLORS.NOT_APPLICABLE, trueColor = COLORS.TRUE, falseColor = COLORS.FALSE) => value == null ? nullColor("\u2205") : value ? trueColor("\u2713") : falseColor("\u292B");
var printZodErrors = (error) => {
  const errors = error.flatten((issue) => {
    var _a, _b;
    const propertyPath = (_b = (_a = issue.path) == null ? void 0 : _a.join(".")) != null ? _b : "";
    if (propertyPath === "") {
      return issue.message;
    }
    return `Property '${propertyPath}': ${issue.message}`;
  });
  const formErrors = errors.formErrors;
  const fieldErrors = Object.values(errors.fieldErrors).flat();
  const allErrors = [...formErrors, ...fieldErrors];
  return allErrors.join(`
`);
};
var createConfigLoader = (schema, logger2 = createModuleLogger("config loader")) => async (path) => {
  const absolutePath = resolve(path);
  logger2.verbose(`Resolved config file location for '${path}': '${absolutePath}'`);
  logger2.verbose(`Checking config file '${absolutePath}' for existence & readability`);
  const isConfigReadable = isFile(absolutePath) && isReadable(absolutePath);
  if (!isConfigReadable) {
    throw new Error(
      `Unable to read config file '${path}'. Check that the file exists and is readable to your terminal user`
    );
  }
  logger2.verbose(`Config file '${absolutePath}' exists & is readable`);
  let rawConfig;
  try {
    logger2.verbose(`Loading config file '${absolutePath}'`);
    rawConfig = await importDefault(absolutePath);
  } catch (error) {
    throw new Error(`Unable to read config file '${path}': ${error}`);
  }
  logger2.verbose(`Loaded config file '${absolutePath}'`);
  let rawConfigMaterialized;
  if (typeof rawConfig === "function") {
    logger2.verbose(`Executing configuration function from config file '${absolutePath}'`);
    try {
      rawConfigMaterialized = await rawConfig();
    } catch (error) {
      throw new Error(`Got an exception while executing config funtion from file '${path}': ${error}`);
    }
  } else {
    logger2.verbose(`Using exported value from config file '${absolutePath}'`);
    rawConfigMaterialized = rawConfig;
  }
  logger2.verbose(`Validating the structure of config file '${absolutePath}'`);
  const configParseResult = await schema.safeParseAsync(rawConfigMaterialized);
  if (configParseResult.success === false) {
    const userFriendlyErrors = printZodErrors(configParseResult.error);
    throw new Error(
      `Config from file '${path}' is malformed. Please fix the following errors:

${userFriendlyErrors}`
    );
  }
  return configParseResult.data;
};

// src/language/plurals.ts
var cardinalRules = new Intl.PluralRules("en-US");
var ordinalRules = new Intl.PluralRules("en-US", { type: "ordinal" });
var ordinals = {
  one: "st",
  two: "nd",
  few: "rd",
  other: "th",
  zero: "th",
  many: "th"
};
var pluralizeOrdinal = (n) => {
  const rule = ordinalRules.select(n);
  const suffix = ordinals[rule];
  return `${n}${suffix}`;
};
var pluralizeNoun = (n, singular, plural = `${singular}s`) => {
  const rule = cardinalRules.select(n);
  if (rule === "one") {
    return singular;
  }
  return plural;
};
var handlePromptState = (state) => {
  if (state.aborted) {
    process.stdout.write("\x1B[?25h");
    process.stdout.write("\n");
    process.exit(1);
  }
};
var promptToContinue = async (message = "Do you want to continue?", defaultValue = true) => {
  const { value } = await prompts({
    type: "confirm",
    name: "value",
    message,
    initial: defaultValue,
    onState: handlePromptState
  });
  assert(typeof value === "boolean", `Invariant error: Expected a boolean response, got ${value}`);
  return value;
};
var promptForText = async (message = "Do you want to continue?", { defaultValue, hint, validate } = {}) => {
  const { value } = await prompts({
    type: "text",
    name: "value",
    hint,
    message,
    onState: handlePromptState,
    validate,
    initial: defaultValue
  });
  return value;
};
var promptToSelectOne = async (message, { options }) => {
  const { value } = await prompts({
    type: "select",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState
  });
  return value;
};
var promptToSelectMultiple = async (message, { options, disabledHint, min, max }) => {
  const { value } = await prompts({
    type: "autocompleteMultiselect",
    name: "value",
    message,
    choices: options,
    onState: handlePromptState,
    warn: disabledHint,
    min,
    max
  });
  return value;
};

// src/stdio/debugLogger.ts
var DebugLogger = class {
  static keyValue(key, value, indentLevel = 0) {
    const indent = " ".repeat(indentLevel * 2);
    console.log(`${indent}\x1B[33m${key}:\x1B[0m ${value}`);
  }
  static keyHeader(key, indentLevel = 0) {
    const indent = " ".repeat(indentLevel * 2);
    console.log(`${indent}\x1B[33m${key}:\x1B[0m`);
  }
  static header(text) {
    console.log(`\x1B[36m${text}\x1B[0m`);
  }
  static separator() {
    console.log("\x1B[90m----------------------------------------\x1B[0m");
  }
  static printErrorAndFixSuggestion(type, errorMsg) {
    const fixInfo = ERRORS_FIXES_MAP[type];
    if (!fixInfo) {
      console.log(`\x1B[31mError:\x1B[0m Unknown error type "${type}"`);
      return;
    }
    const errorOutput = errorMsg ? `${type}: (${errorMsg})` : type;
    console.log(`\x1B[31mError:\x1B[0m ${errorOutput}`);
    console.log(`\x1B[32mFix suggestion:\x1B[0m ${fixInfo.tip}`);
    if (fixInfo.info) {
      console.log(`\x1B[34mElaboration:\x1B[0m ${fixInfo.info}`);
    }
    console.log();
  }
  static printWarning(type, message) {
    const label = `\x1B[33mWarning:\x1B[0m`;
    console.log(`${label} ${type}${message ? ` \u2013 ${message}` : ""}`);
  }
  static printLayerZeroOutput(type, payload) {
    logger.info(`${payload ? " " + payload : ""}`);
  }
};
var KnownErrors = /* @__PURE__ */ ((KnownErrors2) => {
  KnownErrors2["ULN_INIT_CONFIG_SKIPPED"] = "ULN_INIT_CONFIG_SKIPPED";
  KnownErrors2["ERROR_QUOTING_NATIVE_GAS_COST"] = "ERROR_QUOTING_NATIVE_GAS_COST";
  KnownErrors2["ERROR_SENDING_TRANSACTION"] = "ERROR_SENDING_TRANSACTION";
  KnownErrors2["ERROR_GETTING_HRE"] = "ERROR_GETTING_HARDHAT_RUNTIME_ENVIRONMENT_FOR_NETWORK";
  KnownErrors2["SOLANA_INVALID_OWNER_OR_DELEGATE"] = "SOLANA_INVALID_OWNER_OR_DELEGATE";
  KnownErrors2["SOLANA_OWNER_OR_DELEGATE_CANNOT_BE_MULTISIG_ACCOUNT"] = "SOLANA_OWNER_OR_DELEGATE_MULTISIG_ACCOUNT";
  return KnownErrors2;
})(KnownErrors || {});
var KnownWarnings = /* @__PURE__ */ ((KnownWarnings2) => {
  KnownWarnings2["OFT_PROGRAM_NOT_DEPLOYED"] = "OFT Program Not Deployed";
  KnownWarnings2["USING_OVERRIDE_OFT"] = "Using address provided as an OFT deployment";
  KnownWarnings2["SOLANA_DEPLOYMENT_MISSING_OFT_STORE"] = "Solana deployment missing OFT store";
  KnownWarnings2["SOLANA_DEPLOYMENT_NOT_FOUND"] = "SOLANA_DEPLOYMENT_NOT_FOUND";
  KnownWarnings2["ERROR_LOADING_SOLANA_DEPLOYMENT"] = "Error loading local Solana deployment";
  return KnownWarnings2;
})(KnownWarnings || {});
var KnownOutputs = /* @__PURE__ */ ((KnownOutputs2) => {
  KnownOutputs2["TX_HASH"] = "Transaction hash";
  KnownOutputs2["EXPLORER_LINK"] = "LayerZero scan link";
  KnownOutputs2["SENT_VIA_OFT"] = "OFT sent successfully";
  return KnownOutputs2;
})(KnownOutputs || {});
var ERRORS_FIXES_MAP = {
  ["ULN_INIT_CONFIG_SKIPPED" /* ULN_INIT_CONFIG_SKIPPED */]: {
    tip: "Did you run `npx hardhat lz:oft:solana:init-config --oapp-config <LZ_CONFIG_FILE_NAME> ?",
    info: "You must run lz:oft:solana:init-config once before you run lz:oapp:wire. If you have added new pathways, you must also run lz:oft:solana:init-config again."
  },
  ["ERROR_QUOTING_NATIVE_GAS_COST" /* ERROR_QUOTING_NATIVE_GAS_COST */]: {
    tip: "Have you run `npx hardhat lz:oapp:config:get --oapp-config <LZ_CONFIG_FILE_NAME>` and checked that you correctly configured the pathway?",
    info: "LayerZero pathways require that a default Endpoint, Message Library, and DVN configuration exists for messaging to work. See https://layerzeroscan.com/tools/defaults for more information."
  },
  ["ERROR_SENDING_TRANSACTION" /* ERROR_SENDING_TRANSACTION */]: {
    tip: "Have you correctly passed the quoteSend() result to the send() function?",
    info: "To quote the native gas cost needed to send a message, you must pass the result of quoteSend() to the send() function."
  },
  ["ERROR_GETTING_HARDHAT_RUNTIME_ENVIRONMENT_FOR_NETWORK" /* ERROR_GETTING_HRE */]: {
    tip: "Have you added the srcEid network to your `./hardhat.config.ts` file?",
    info: "If you loaded a custom OFT deployment from an EVM network, you must add the deployment srcEid to your `./hardhat.config.ts` file for the OFT to be found."
  },
  ["SOLANA_INVALID_OWNER_OR_DELEGATE" /* SOLANA_INVALID_OWNER_OR_DELEGATE */]: {
    tip: "The owner or delegate of the Solana OApp must either be a regular on curve address or a Squads Vault Account.",
    info: "Ensure that you are using a regular on-curve Solana address or a Squads Vault PDA as the owner or delegate of the OApp."
  },
  ["SOLANA_OWNER_OR_DELEGATE_MULTISIG_ACCOUNT" /* SOLANA_OWNER_OR_DELEGATE_CANNOT_BE_MULTISIG_ACCOUNT */]: {
    tip: "The owner or delegate of the Solana OApp must not be the Squads multisig account address.",
    info: "If you intend to use Squads Multisig, ensure that you are providing a Squads Vault address as the owner or delegate of the OApp. The Squads Multisig account address cannot be the owner or delegate."
  }
};
var WARNINGS_FIXES_MAP = {
  ["SOLANA_DEPLOYMENT_NOT_FOUND" /* SOLANA_DEPLOYMENT_NOT_FOUND */]: {
    tip: "Did you run `npx hardhat lz:oft:solana:create` ?",
    info: "The Solana deployment file is required to run config tasks. The default path is ./deployments/solana-<mainnet/testnet>/OFT.json"
  },
  ["OFT Program Not Deployed" /* OFT_PROGRAM_NOT_DEPLOYED */]: {
    tip: "Deploy the OFT program first",
    info: "The OFT program must be deployed before proceeding with other operations"
  },
  ["Using address provided as an OFT deployment" /* USING_OVERRIDE_OFT */]: {
    tip: "Using external OFT deployment",
    info: "This is expected when using an external OFT deployment"
  },
  ["Solana deployment missing OFT store" /* SOLANA_DEPLOYMENT_MISSING_OFT_STORE */]: {
    tip: "OFT store is missing from deployment",
    info: "The OFT store must be initialized in the deployment"
  },
  ["Error loading local Solana deployment" /* ERROR_LOADING_SOLANA_DEPLOYMENT */]: {
    tip: "Failed to load Solana deployment",
    info: "Check if the deployment file exists and is properly formatted"
  }
};
var logger = createLogger();

export { COLORS, DebugLogger, ERRORS_FIXES_MAP, KnownErrors, KnownOutputs, KnownWarnings, LogLevel, WARNINGS_FIXES_MAP, createConfigLoader, createLogger, createModuleInteractionLogger, createModuleLogger, createWithAsyncLogger, handlePromptState, importDefault, isDirectory, isFile, isLogLevel, isReadable, pluralizeNoun, pluralizeOrdinal, printBoolean, printCrossTable, printJson, printRecord, printZodErrors, promptForText, promptToContinue, promptToSelectMultiple, promptToSelectOne, setDefaultLogLevel, sleep };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map