{
  "id": "edf0138b97898d26cfc0e872ce8b1c0b",
  "solcLongVersion": "0.7.6+commit.d1802f25.Emscripten.clang",
  "input": {
    "language": "Solidity",
    "sources": {
      "contracts/precrime/example/inherit/CounterI.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./CounterPrecrime.sol\";\n\ncontract CounterI is CounterPrecrime {\n    // keep track of how many messages have been received from other chains\n    uint public totalCount;\n    mapping(uint32 => uint) public inboundCount;\n    mapping(uint32 => uint) public outboundCount;\n\n    event Send(uint16 dstChainId);\n    event Receive(uint16 srcChainId);\n\n    uint16 public chainId;\n\n    constructor(uint16 _chainId) CounterPrecrime(_chainId) {\n        chainId = _chainId;\n    }\n\n    function lzReceive(uint16 _srcChainId) public {\n        inboundCount[_srcChainId]++;\n        totalCount++;\n\n        emit Receive(_srcChainId);\n    }\n\n    function increment(uint16 _dstChainId) external {\n        outboundCount[_dstChainId]++;\n\n        emit Send(_dstChainId);\n    }\n\n    function brokeIncrement(uint16 _dstChainId) external {\n        emit Send(_dstChainId);\n    }\n\n    function brokeTotalCount() external {\n        totalCount++;\n    }\n\n    function getInboundNonce(uint32 _chainId) public view returns (uint) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return inboundCount[_chainId];\n    }\n\n    // ------------- precrime -----------------\n    function _lzReceiveByPacket(Packet calldata _packet) internal virtual override {\n        lzReceive(uint16(_packet.srcChainId));\n    }\n\n    function getCountState(uint16[] memory peers) public view virtual override returns (CountState memory) {\n        ChainPathCount[] memory chainPathCounts = new ChainPathCount[](peers.length);\n        for (uint i = 0; i < peers.length; i++) {\n            uint16 peer = peers[i];\n            chainPathCounts[i] = ChainPathCount({\n                eid: peer,\n                inboundCount: inboundCount[peer],\n                outboundCount: outboundCount[peer]\n            });\n        }\n\n        CountState memory countState = CountState({totalCount: totalCount, chainPathCounts: chainPathCounts});\n\n        return countState;\n    }\n\n    function _getInboundNonce(Packet memory packet) internal view override returns (uint64) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return uint64(inboundCount[packet.srcChainId]);\n    }\n}\n"
      },
      "contracts/precrime/example/inherit/CounterPrecrime.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../../PreCrime.sol\";\n\nabstract contract CounterPrecrime is PreCrime {\n    uint16[] public remoteChainIds;\n    bytes32[] public remotePrecrimeAddresses;\n\n    struct SimulationResult {\n        uint16 chainId;\n        CountState countState;\n    }\n\n    struct CountState {\n        uint totalCount;\n        ChainPathCount[] chainPathCounts;\n    }\n\n    struct ChainPathCount {\n        uint16 eid;\n        uint inboundCount;\n        uint outboundCount;\n    }\n\n    constructor(uint16 _localChainId) PreCrime(_localChainId) {\n        maxBatchSize = 10;\n    }\n\n    function setRemotePrecrimeAddresses(\n        uint16[] memory _remoteChainIds,\n        bytes32[] memory _remotePrecrimeAddresses\n    ) public onlyPrecrimeAdmin {\n        require(_remoteChainIds.length == _remotePrecrimeAddresses.length, \"Precrime: invalid size\");\n        remoteChainIds = _remoteChainIds;\n        remotePrecrimeAddresses = _remotePrecrimeAddresses;\n    }\n\n    function _simulate(Packet[] calldata _packets) internal override returns (uint16 code, bytes memory data) {\n        // simulate\n        for (uint256 i = 0; i < _packets.length; i++) {\n            _lzReceiveByPacket(_packets[i]);\n        }\n\n        // return simulation result\n        bytes memory result = abi.encode(\n            SimulationResult({chainId: localChainId, countState: getCountState(remoteChainIds)})\n        );\n        return (CODE_SUCCESS, result);\n    }\n\n    function _precrime(\n        bytes[] memory _simulation\n    ) internal view virtual override returns (uint16 code, bytes memory reason) {\n        (SimulationResult memory localResult, SimulationResult[] memory results) = _getLocalSimulateResult(_simulation);\n\n        uint sumOutboundCount = 0;\n        // for each chainPathCount, find the chainPathCount and check the counts\n        for (uint256 j = 0; j < localResult.countState.chainPathCounts.length; j++) {\n            ChainPathCount memory cpCount = localResult.countState.chainPathCounts[j];\n            // find remote to local count state\n            // should provide all peers simulated results\n            ChainPathCount memory remoteCp = _getRemoteCpCount(results, cpCount.eid);\n            (code, reason) = _assertChainPathCount(cpCount, remoteCp);\n            if (code != CODE_SUCCESS) {\n                return (code, reason);\n            }\n            sumOutboundCount += remoteCp.outboundCount; // remote to local outbound count\n        }\n        (code, reason) = _assertTotalCount(localResult.countState, sumOutboundCount);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _lzReceiveByPacket(Packet calldata _packet) internal virtual;\n\n    /**\n     * @notice Get the count states for a list of peers\n     * @param peers - the list of remote chainId to get counts for\n     * @return counts - the CountState with the total count and the chain path counts\n     */\n    function getCountState(uint16[] memory peers) public view virtual returns (CountState memory);\n\n    function _getRemoteCpCount(\n        SimulationResult[] memory _results,\n        uint16 _remoteId\n    ) internal view returns (ChainPathCount memory) {\n        uint localEid = localChainId;\n        for (uint256 i = 0; i < _results.length; i++) {\n            SimulationResult memory remoteResult = _results[i];\n            if (remoteResult.chainId == _remoteId) {\n                for (uint256 j = 0; j < remoteResult.countState.chainPathCounts.length; j++) {\n                    ChainPathCount memory cpCount = remoteResult.countState.chainPathCounts[j];\n                    if (cpCount.eid == localEid) {\n                        // find to localEid path\n                        return cpCount;\n                    }\n                }\n            }\n        }\n        revert(\"Precrime: countState not found, are you missing a simulation?\");\n    }\n\n    function _getLocalSimulateResult(\n        bytes[] memory _simulation\n    ) internal view returns (SimulationResult memory localResult, SimulationResult[] memory results) {\n        // decode results\n        results = new SimulationResult[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            bytes memory result = _simulation[i];\n            results[i] = abi.decode(result, (SimulationResult));\n            if (results[i].chainId == localChainId) {\n                localResult = results[i];\n            }\n        }\n    }\n\n    function _assertChainPathCount(\n        ChainPathCount memory _localCpCount,\n        ChainPathCount memory _remoteCpCount\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCpCount.inboundCount > _remoteCpCount.outboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: inboundCount > outboundCount\");\n        }\n        if (_localCpCount.outboundCount > _remoteCpCount.inboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: outboundCount > inboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _assertTotalCount(\n        CountState memory _localCount,\n        uint _sumOutbound\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCount.totalCount > _sumOutbound) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: totalCount > sum outboundCount\");\n        }\n    }\n\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view override returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {\n        if (_packets.length == 0) {\n            return (remoteChainIds, remotePrecrimeAddresses);\n        }\n\n        // only return related remotes\n        uint16 size = _getRelatedRemoteSize(_packets);\n        if (size > 0) {\n            chainIds = new uint16[](size);\n            uint256 k = 0;\n            precrimeAddresses = new bytes32[](size);\n            for (uint16 i = 0; i < remoteChainIds.length; i++) {\n                for (uint16 j = 0; j < _packets.length; j++) {\n                    uint16 srcChainId = _packets[j].srcChainId;\n                    if (remoteChainIds[i] == srcChainId) {\n                        chainIds[k] = srcChainId;\n                        precrimeAddresses[k] = remotePrecrimeAddresses[i];\n                        k++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _getRelatedRemoteSize(Packet[] memory _packets) internal view returns (uint16 size) {\n        for (uint16 i = 0; i < remoteChainIds.length; i++) {\n            for (uint16 j = 0; j < _packets.length; j++) {\n                if (remoteChainIds[i] == _packets[j].srcChainId) {\n                    size++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"
      },
      "contracts/precrime/example/view/CounterPrecrimeView.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../../PreCrimeView.sol\";\nimport \"./CounterView.sol\";\nimport \"./CounterV.sol\";\n\ncontract CounterPrecrimeView is PreCrimeView {\n    CounterView public counterView;\n\n    uint16[] public remoteChainIds;\n    bytes32[] public remotePrecrimeAddresses;\n\n    struct SimulationResult {\n        uint16 chainId;\n        CounterView.CountState countState;\n    }\n\n    constructor(uint16 _localChainId, address _counterView) PreCrimeView(_localChainId) {\n        counterView = CounterView(_counterView);\n        maxBatchSize = 10;\n    }\n\n    function setRemotePrecrimeAddresses(\n        uint16[] memory _remoteChainIds,\n        bytes32[] memory _remotePrecrimeAddresses\n    ) public onlyPrecrimeAdmin {\n        require(_remoteChainIds.length == _remotePrecrimeAddresses.length, \"Precrime: invalid size\");\n        remoteChainIds = _remoteChainIds;\n        remotePrecrimeAddresses = _remotePrecrimeAddresses;\n    }\n\n    function setCounterView(address _counterView) public onlyPrecrimeAdmin {\n        counterView = CounterView(_counterView);\n    }\n\n    function _simulate(Packet[] calldata _packets) internal view override returns (uint16 code, bytes memory data) {\n        // get state from counter\n        CounterView.CountState memory countState = counterView.getCountState(remoteChainIds);\n\n        // simulate\n        for (uint256 i = 0; i < _packets.length; i++) {\n            Packet memory packet = _packets[i];\n            countState = counterView.lzReceive(countState, packet.srcChainId);\n        }\n\n        // return simulation result\n        return (CODE_SUCCESS, abi.encode(SimulationResult({chainId: localChainId, countState: countState})));\n    }\n\n    function _precrime(\n        bytes[] memory _simulation\n    ) internal view virtual override returns (uint16 code, bytes memory reason) {\n        (SimulationResult memory localResult, SimulationResult[] memory results) = _getLocalSimulateResult(_simulation);\n\n        uint sumOutboundCount = 0;\n        // for each chainPathCount, find the chainPathCount and check the counts\n        for (uint256 j = 0; j < localResult.countState.chainPathCounts.length; j++) {\n            CounterView.ChainPathCount memory cpCount = localResult.countState.chainPathCounts[j];\n            // find remote to local count state\n            // should provide all peers simulated results\n            CounterView.ChainPathCount memory remoteCp = _getRemoteCpCount(results, cpCount.eid);\n            (code, reason) = _assertChainPathCount(cpCount, remoteCp);\n            if (code != CODE_SUCCESS) {\n                return (code, reason);\n            }\n            sumOutboundCount += remoteCp.outboundCount; // remote to local outbound count\n        }\n        (code, reason) = _assertTotalCount(localResult.countState, sumOutboundCount);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _getRemoteCpCount(\n        SimulationResult[] memory _results,\n        uint16 _remoteId\n    ) internal view returns (CounterView.ChainPathCount memory) {\n        uint localEid = localChainId;\n        for (uint256 i = 0; i < _results.length; i++) {\n            SimulationResult memory remoteResult = _results[i];\n            if (remoteResult.chainId == _remoteId) {\n                for (uint256 j = 0; j < remoteResult.countState.chainPathCounts.length; j++) {\n                    CounterView.ChainPathCount memory cpCount = remoteResult.countState.chainPathCounts[j];\n                    if (cpCount.eid == localEid) {\n                        // find to localEid path\n                        return cpCount;\n                    }\n                }\n            }\n        }\n        revert(\"Precrime: count state not found\");\n    }\n\n    function _getLocalSimulateResult(\n        bytes[] memory _simulation\n    ) internal view returns (SimulationResult memory localResult, SimulationResult[] memory results) {\n        // decode results\n        results = new SimulationResult[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            results[i] = abi.decode(_simulation[i], (SimulationResult));\n            if (results[i].chainId == localChainId) {\n                localResult = results[i];\n            }\n        }\n    }\n\n    function _assertChainPathCount(\n        CounterView.ChainPathCount memory _localCpCount,\n        CounterView.ChainPathCount memory _remoteCpCount\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCpCount.inboundCount > _remoteCpCount.outboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: inboundCount > outboundCount\");\n        }\n        if (_localCpCount.outboundCount > _remoteCpCount.inboundCount) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: outboundCount > inboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _assertTotalCount(\n        CounterView.CountState memory _localCount,\n        uint _sumOutbound\n    ) internal pure returns (uint16 code, bytes memory reason) {\n        if (_localCount.totalCount > _sumOutbound) {\n            return (CODE_PRECRIME_FAILURE, \"Precrime: totalCount > sum outboundCount\");\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view override returns (uint16[] memory chainIds, bytes32[] memory precrimeAddresses) {\n        if (_packets.length == 0) {\n            return (remoteChainIds, remotePrecrimeAddresses);\n        }\n\n        // only return related remotes\n        uint16 size = _getRelatedRemoteSize(_packets);\n        if (size > 0) {\n            chainIds = new uint16[](size);\n            uint256 k = 0;\n            precrimeAddresses = new bytes32[](size);\n            for (uint16 i = 0; i < remoteChainIds.length; i++) {\n                for (uint16 j = 0; j < _packets.length; j++) {\n                    uint16 srcChainId = _packets[j].srcChainId;\n                    if (remoteChainIds[i] == srcChainId) {\n                        chainIds[k] = srcChainId;\n                        precrimeAddresses[k] = remotePrecrimeAddresses[i];\n                        k++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function _getRelatedRemoteSize(Packet[] memory _packets) internal view returns (uint16 size) {\n        for (uint16 i = 0; i < remoteChainIds.length; i++) {\n            for (uint16 j = 0; j < _packets.length; j++) {\n                if (remoteChainIds[i] == _packets[j].srcChainId) {\n                    size++;\n                    break;\n                }\n            }\n        }\n    }\n\n    function _getInboundNonce(Packet memory packet) internal view override returns (uint64) {\n        CounterV counter = counterView.counter();\n        return counter.getInboundNonce(packet.srcChainId);\n    }\n}\n"
      },
      "contracts/precrime/example/view/CounterV.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\ncontract CounterV {\n    // keep track of how many messages have been received from other chains\n    uint public totalCount;\n    mapping(uint32 => uint) public inboundCount;\n    mapping(uint32 => uint) public outboundCount;\n\n    event Send(uint16 dstChainId);\n    event Receive(uint16 srcChainId);\n\n    uint16 public chainId;\n\n    constructor(uint16 _chainId) {\n        chainId = _chainId;\n    }\n\n    function lzReceive(uint16 _srcChainId) external {\n        inboundCount[_srcChainId]++;\n        totalCount++;\n\n        emit Receive(_srcChainId);\n    }\n\n    function increment(uint16 _dstChainId) external {\n        outboundCount[_dstChainId]++;\n\n        emit Send(_dstChainId);\n    }\n\n    function brokeIncrement(uint16 _dstChainId) external {\n        emit Send(_dstChainId);\n    }\n\n    function brokeTotalCount() external {\n        totalCount++;\n    }\n\n    function getInboundNonce(uint16 _chainId) public view returns (uint64) {\n        // in reality, this would be a call to the LayerZero endpoint\n        return uint64(inboundCount[_chainId]);\n    }\n}\n"
      },
      "contracts/precrime/example/view/CounterView.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./CounterV.sol\";\n\ncontract CounterView {\n    struct CountState {\n        uint totalCount;\n        ChainPathCount[] chainPathCounts;\n    }\n\n    struct ChainPathCount {\n        uint16 eid;\n        uint inboundCount;\n        uint outboundCount;\n    }\n\n    CounterV public counter;\n\n    constructor(address _counter) {\n        counter = CounterV(_counter);\n    }\n\n    function lzReceive(CountState memory countState, uint16 _srcChainId) public pure returns (CountState memory) {\n        // do receive logic\n        for (uint i = 0; i < countState.chainPathCounts.length; i++) {\n            ChainPathCount memory chainPathCount = countState.chainPathCounts[i];\n            if (chainPathCount.eid == _srcChainId) {\n                countState.totalCount++;\n                chainPathCount.inboundCount++;\n                countState.chainPathCounts[i] = chainPathCount;\n                break;\n            }\n        }\n        return countState;\n    }\n\n    /**\n     * @notice Get the count states for a list of peers\n     * @param peers - the list of remote chainId to get counts for\n     * @return counts - the CountState with the total count and the chain path counts\n     */\n    function getCountState(uint16[] calldata peers) public view returns (CountState memory) {\n        ChainPathCount[] memory chainPathCounts = new ChainPathCount[](peers.length);\n\n        for (uint i = 0; i < peers.length; i++) {\n            uint16 peer = peers[i];\n            chainPathCounts[i] = ChainPathCount({\n                eid: peer,\n                inboundCount: counter.inboundCount(peer),\n                outboundCount: counter.outboundCount(peer)\n            });\n        }\n\n        CountState memory countState = CountState({totalCount: counter.totalCount(), chainPathCounts: chainPathCounts});\n\n        return countState;\n    }\n}\n"
      },
      "contracts/precrime/interfaces/IPreCrime.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IPreCrimeBase.sol\";\n\ninterface IPreCrime is IPreCrimeBase {\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return result the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external returns (uint16 code, bytes memory result);\n}\n"
      },
      "contracts/precrime/interfaces/IPreCrimeBase.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\ninterface IPreCrimeBase {\n    struct Packet {\n        uint16 srcChainId; // source chain id\n        bytes32 srcAddress; // srouce UA address\n        uint64 nonce;\n        bytes payload;\n    }\n\n    /**\n     * @dev get precrime config,\n     * @param _packets packets\n     * @return bytes of [maxBatchSize, remotePrecrimes]\n     */\n    function getConfig(Packet[] calldata _packets) external view returns (bytes memory);\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code defination\n     * @return reason   error reason\n     */\n    function precrime(\n        Packet[] calldata _packets,\n        bytes[] calldata _simulation\n    ) external view returns (uint16 code, bytes memory reason);\n\n    /**\n     * @dev protocol version\n     */\n    function version() external view returns (uint16);\n}\n"
      },
      "contracts/precrime/interfaces/IPreCrimeView.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport \"./IPreCrimeBase.sol\";\n\ninterface IPreCrimeView is IPreCrimeBase {\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return result the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external view returns (uint16 code, bytes memory result);\n}\n"
      },
      "contracts/precrime/PreCrime.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrime.sol\";\nimport \"./PreCrimeBase.sol\";\n\nabstract contract PreCrime is PreCrimeBase, IPreCrime {\n    bytes4 private constant SIMULATE_REVERT_SELECTOR = bytes4(keccak256(\"SimulateRevert(uint16,bytes)\"));\n\n    /**\n     * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode\n     */\n    uint16 public constant PRECRIME_VERSION = 20001;\n\n    constructor(uint16 _localChainId) PreCrimeBase(_localChainId) {}\n\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return data the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external override returns (uint16 code, bytes memory data) {\n        // params check\n        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);\n        if (code != CODE_SUCCESS) {\n            return (code, data);\n        }\n\n        (bool success, bytes memory result) = address(this).call(\n            abi.encodeWithSelector(this._simulateAndRevert.selector, _packets)\n        );\n        require(!success, \"simulate should never return success\");\n\n        // parse code and data\n        (code, data) = _parseRevertResult(result);\n        if (code == CODE_SUCCESS) {\n            data = abi.encode(localChainId, data); // add localChainId to the header\n        }\n    }\n\n    function _parseRevertResult(bytes memory result) internal pure returns (uint16 code, bytes memory data) {\n        // check revert selector\n        bytes4 selector;\n        assembly {\n            selector := mload(add(result, 0x20)) // skip the length and get bytes4 selector\n        }\n        if (selector != SIMULATE_REVERT_SELECTOR) {\n            // bubble up the internal error\n            assembly {\n                revert(add(result, 0x20), mload(result))\n            }\n        }\n\n        // parse code and result\n        assembly {\n            // Slice the sighash. Remove the selector which is the first 4 bytes\n            result := add(result, 0x04)\n        }\n        return abi.decode(result, (uint16, bytes));\n    }\n\n    /**\n     * @dev internal function, no one should call\n     * @param _packets packets\n     */\n    function _simulateAndRevert(Packet[] calldata _packets) external virtual {\n        require(msg.sender == address(this));\n        (uint16 code, bytes memory simulation) = _simulate(_packets);\n        // equal to: revert SimulateRevert(code, result);\n        bytes memory revertData = abi.encodePacked(SIMULATE_REVERT_SELECTOR, abi.encode(code, simulation));\n        assembly {\n            revert(add(revertData, 32), mload(revertData))\n        }\n    }\n\n    /**\n     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.\n     * @param _packets packets\n     * @return code\n     * @return result\n     */\n    function _simulate(Packet[] calldata _packets) internal virtual returns (uint16 code, bytes memory result);\n\n    function version() external pure override returns (uint16) {\n        return PRECRIME_VERSION;\n    }\n}\n"
      },
      "contracts/precrime/PreCrimeBase.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrime.sol\";\n\nabstract contract PreCrimeBase is IPreCrimeBase {\n    uint16 public constant CONFIG_VERSION = 1;\n\n    //---------------- error code ----------------------\n    // --- UA scope code ---\n    uint16 public constant CODE_SUCCESS = 0; // success\n    uint16 public constant CODE_PRECRIME_FAILURE = 1; // !!! crimes found\n\n    // --- protocol scope error code ---\n    // simualte\n    uint16 public constant CODE_PACKETS_OVERSIZE = 2; // packets number bigger then max size\n    uint16 public constant CODE_PACKETS_UNSORTED = 3; // packets are unsorted, need backfill and keep order\n    // precrime\n    uint16 public constant CODE_MISS_SIMULATE_RESULT = 4; // miss simulation result\n\n    uint16 public immutable localChainId;\n    uint64 public maxBatchSize;\n    address public precrimeAdmin;\n\n    modifier onlyPrecrimeAdmin() {\n        require(msg.sender == precrimeAdmin, \"only admin\");\n        _;\n    }\n\n    constructor(uint16 _localChainId) {\n        localChainId = _localChainId;\n        precrimeAdmin = msg.sender;\n    }\n\n    function setPrecrimeAdmin(address _precrimeAdmin) external onlyPrecrimeAdmin {\n        precrimeAdmin = _precrimeAdmin;\n    }\n\n    function setMaxBatchSize(uint64 _maxBatchSize) external onlyPrecrimeAdmin {\n        maxBatchSize = _maxBatchSize;\n    }\n\n    /**\n     * @dev get precrime config,\n     * @param _packets packets\n     * @return configation bytes\n     */\n    function getConfig(Packet[] calldata _packets) external view virtual override returns (bytes memory) {\n        (uint16[] memory remoteChains, bytes32[] memory remoteAddresses) = _remotePrecrimeAddress(_packets);\n        return\n            abi.encodePacked(\n                CONFIG_VERSION,\n                //---- max packets size for simulate batch ---\n                maxBatchSize,\n                //------------- remote precrimes -------------\n                remoteChains.length,\n                remoteChains,\n                remoteAddresses\n            );\n    }\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code definition\n     * @return reason   error reason\n     */\n    function precrime(\n        Packet[] calldata _packets,\n        bytes[] calldata _simulation\n    ) external view override returns (uint16 code, bytes memory reason) {\n        bytes[] memory originSimulateResult = new bytes[](_simulation.length);\n        uint16[] memory chainIds = new uint16[](_simulation.length);\n        for (uint256 i = 0; i < _simulation.length; i++) {\n            (uint16 chainId, bytes memory simulateResult) = abi.decode(_simulation[i], (uint16, bytes));\n            chainIds[i] = chainId;\n            originSimulateResult[i] = simulateResult;\n        }\n\n        (code, reason) = _checkResultsCompleteness(_packets, chainIds);\n        if (code != CODE_SUCCESS) {\n            return (code, reason);\n        }\n\n        (code, reason) = _precrime(originSimulateResult);\n    }\n\n    function _checkPacketsMaxSizeAndNonceOrder(\n        Packet[] calldata _packets\n    ) internal view returns (uint16 code, bytes memory reason) {\n        if (_packets.length > maxBatchSize) {\n            return (CODE_PACKETS_OVERSIZE, abi.encodePacked(\"packets size exceed limited\"));\n        }\n\n        // check packets nonce, sequence order\n        // packets should group by srcChainId and srcAddress, then sort by nonce ascending\n        if (_packets.length > 0) {\n            uint16 srcChainId;\n            bytes32 srcAddress;\n            uint64 nonce;\n            for (uint256 i = 0; i < _packets.length; i++) {\n                Packet memory packet = _packets[i];\n                // start from a new chain packet or a new source UA\n                if (packet.srcChainId != srcChainId || packet.srcAddress != srcAddress) {\n                    srcChainId = packet.srcChainId;\n                    srcAddress = packet.srcAddress;\n                    nonce = packet.nonce;\n                    uint64 nextInboundNonce = _getInboundNonce(packet) + 1;\n                    // the first packet's nonce must equal to dst InboundNonce+1\n                    if (nonce != nextInboundNonce) {\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\"skipped inboundNonce forbidden\"));\n                    }\n                } else {\n                    // the following packet's nonce add 1 in order\n                    if (packet.nonce != ++nonce) {\n                        return (CODE_PACKETS_UNSORTED, abi.encodePacked(\"unsorted packets\"));\n                    }\n                }\n            }\n        }\n        return (CODE_SUCCESS, \"\");\n    }\n\n    function _checkResultsCompleteness(\n        Packet[] calldata _packets,\n        uint16[] memory _resultChainIds\n    ) internal view returns (uint16 code, bytes memory reason) {\n        // check if all remote result included\n        if (_packets.length > 0) {\n            (uint16[] memory remoteChains, ) = _remotePrecrimeAddress(_packets);\n            for (uint256 i = 0; i < remoteChains.length; i++) {\n                bool resultChainIdChecked;\n                for (uint256 j = 0; j < _resultChainIds.length; j++) {\n                    if (_resultChainIds[j] == remoteChains[i]) {\n                        resultChainIdChecked = true;\n                        break;\n                    }\n                }\n                if (!resultChainIdChecked) {\n                    return (CODE_MISS_SIMULATE_RESULT, \"missing remote simulation result\");\n                }\n            }\n        }\n        // check if local result included\n        bool localChainIdResultChecked;\n        for (uint256 j = 0; j < _resultChainIds.length; j++) {\n            if (_resultChainIds[j] == localChainId) {\n                localChainIdResultChecked = true;\n                break;\n            }\n        }\n        if (!localChainIdResultChecked) {\n            return (CODE_MISS_SIMULATE_RESULT, \"missing local simulation result\");\n        }\n\n        return (CODE_SUCCESS, \"\");\n    }\n\n    /**\n     * @dev\n     * @param _simulation all simulation results from difference chains\n     * @return code     precrime result code; check out the error code defination\n     * @return reason   error reason\n     */\n    function _precrime(bytes[] memory _simulation) internal view virtual returns (uint16 code, bytes memory reason);\n\n    /**\n     * @dev UA return trusted remote precrimes by packets\n     * @param _packets packets\n     * @return\n     */\n    function _remotePrecrimeAddress(\n        Packet[] calldata _packets\n    ) internal view virtual returns (uint16[] memory, bytes32[] memory);\n\n    /**\n     * get srcChain & srcAddress InboundNonce by packet\n     */\n    function _getInboundNonce(Packet memory packet) internal view virtual returns (uint64 nonce);\n}\n"
      },
      "contracts/precrime/PreCrimeView.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IPreCrimeView.sol\";\nimport \"./PreCrimeBase.sol\";\n\nabstract contract PreCrimeView is PreCrimeBase, IPreCrimeView {\n    /**\n     * @dev 10000 - 20000 is for view mode, 20000 - 30000 is for precrime inherit mode\n     */\n    uint16 public constant PRECRIME_VERSION = 10001;\n\n    constructor(uint16 _localChainId) PreCrimeBase(_localChainId) {}\n\n    /**\n     * @dev simulate run cross chain packets and get a simulation result for precrime later\n     * @param _packets packets, the packets item should group by srcChainId, srcAddress, then sort by nonce\n     * @return code   simulation result code; see the error code defination\n     * @return data the result is use for precrime params\n     */\n    function simulate(Packet[] calldata _packets) external view override returns (uint16 code, bytes memory data) {\n        // params check\n        (code, data) = _checkPacketsMaxSizeAndNonceOrder(_packets);\n        if (code != CODE_SUCCESS) {\n            return (code, data);\n        }\n\n        (code, data) = _simulate(_packets);\n        if (code == CODE_SUCCESS) {\n            data = abi.encode(localChainId, data); // add localChainId to the header\n        }\n    }\n\n    /**\n     * @dev UA execute the logic by _packets, and return simulation result for precrime. would revert state after returned result.\n     * @param _packets packets\n     * @return code\n     * @return result\n     */\n    function _simulate(Packet[] calldata _packets) internal view virtual returns (uint16 code, bytes memory result);\n\n    function version() external pure override returns (uint16) {\n        return PRECRIME_VERSION;\n    }\n}\n"
      }
    },
    "settings": {
      "optimizer": {
        "enabled": true,
        "runs": 10000
      },
      "outputSelection": {
        "*": {
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata",
            "devdoc",
            "userdoc",
            "storageLayout",
            "evm.gasEstimates"
          ],
          "": [
            "ast"
          ]
        }
      },
      "metadata": {
        "useLiteralContent": true
      }
    }
  }
}